<script data-pjax>
(() => {
  if (window.__siteThemeController) {
    window.__siteThemeController.refresh();
    return;
  }

  const STORAGE_KEY = 'theme-preference';
  const THEME_LIGHT = 'light';
  const THEME_DARK = 'dark';
  const THEME_SYSTEM = 'system';
  const THEME_COLORS = {
    light: '#edf5ff',
    dark : '#071528'
  };
  const root = document.documentElement;
  const media = window.matchMedia('(prefers-color-scheme: dark)');
  const isValidTheme = theme => theme === THEME_DARK || theme === THEME_LIGHT;
  let squaresController = null;
  let themeAnimTimer = 0;

  function getSavedTheme() {
    try {
      const value = localStorage.getItem(STORAGE_KEY);
      return isValidTheme(value) ? value : THEME_SYSTEM;
    } catch (error) {
      return THEME_SYSTEM;
    }
  }

  function getEffectiveTheme(theme) {
    if (isValidTheme(theme)) return theme;
    return media.matches ? THEME_DARK : THEME_LIGHT;
  }

  function ensureThemeColorMeta() {
    let meta = document.querySelector('meta[name="theme-color"][data-managed="true"]');
    if (!meta) {
      meta = document.createElement('meta');
      meta.name = 'theme-color';
      meta.setAttribute('data-managed', 'true');
      document.head.appendChild(meta);
    }
    return meta;
  }

  function syncThemeColorMeta(effectiveTheme) {
    const meta = ensureThemeColorMeta();
    meta.content = effectiveTheme === THEME_DARK ? THEME_COLORS.dark : THEME_COLORS.light;
  }

  function ensureMenuToggle() {
    const menu = document.querySelector('.main-menu.menu');
    if (!menu) return null;

    let item = menu.querySelector('.menu-item-theme-toggle');
    if (!item) {
      item = document.createElement('li');
      item.className = 'menu-item menu-item-theme-toggle';
      item.innerHTML = '<a role="button" class="theme-menu-trigger"><i class="fa fa-moon fa-fw theme-menu-icon"></i><span class="theme-menu-text">夜间</span></a>';
      const searchItem = menu.querySelector('.menu-item-search');
      if (searchItem) {
        menu.insertBefore(item, searchItem);
      } else {
        menu.appendChild(item);
      }
    }
    return item.querySelector('a');
  }

  function updateMenuButton(effectiveTheme) {
    const trigger = ensureMenuToggle();
    if (!trigger) return;

    const item = trigger.closest('.menu-item-theme-toggle');
    const icon = trigger.querySelector('.theme-menu-icon');
    const text = trigger.querySelector('.theme-menu-text');
    const isDark = effectiveTheme === THEME_DARK;
    const label = isDark ? '切换到浅色模式' : '切换到夜间模式';

    trigger.setAttribute('aria-label', label);
    trigger.setAttribute('title', label);
    if (item) item.classList.toggle('is-dark', isDark);

    if (icon) {
      icon.classList.toggle('fa-moon', !isDark);
      icon.classList.toggle('fa-sun', isDark);
    }
    if (text) text.textContent = isDark ? '浅色' : '夜间';
  }

  function bindToggle(trigger) {
    if (!trigger || trigger.dataset.bound === 'true') return;
    trigger.dataset.bound = 'true';
    trigger.addEventListener('click', event => {
      event.preventDefault();
      toggleTheme();
    });
  }

  function ensureBackdrop() {
    let backdrop = document.getElementById('rb-dark-backdrop');
    if (!backdrop) {
      backdrop = document.createElement('div');
      backdrop.id = 'rb-dark-backdrop';
      backdrop.setAttribute('aria-hidden', 'true');
      backdrop.innerHTML = `
        <canvas id="rb-dark-squares"></canvas>
      `;
      document.body.prepend(backdrop);
    }
    return backdrop;
  }

  function ensureLightBackdrop() {
    let backdrop = document.getElementById('rb-light-backdrop');
    if (!backdrop) {
      backdrop = document.createElement('div');
      backdrop.id = 'rb-light-backdrop';
      backdrop.setAttribute('aria-hidden', 'true');
      backdrop.innerHTML = `
        <div class="rb-light-orb orb-a"></div>
        <div class="rb-light-orb orb-b"></div>
        <div class="rb-light-grid"></div>
      `;
      document.body.prepend(backdrop);
    }
    return backdrop;
  }

  function ensureThemeTransitionLayer() {
    let layer = document.getElementById('rb-theme-transition-layer');
    if (!layer) {
      layer = document.createElement('div');
      layer.id = 'rb-theme-transition-layer';
      layer.setAttribute('aria-hidden', 'true');
      document.body.prepend(layer);
    }
    return layer;
  }

  // Adapted from the React Bits "Squares" background effect.
  function createSquaresController(canvas) {
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;

    const state = {
      squareSize: 56,
      speed: 0.32,
      borderColor: 'rgba(125, 211, 252, 0.18)',
      hoverColor: 'rgba(45, 212, 191, 0.14)',
      offsetX: 0,
      offsetY: 0,
      width: 0,
      height: 0,
      dpr: 1,
      raf: 0,
      running: false,
      hoverCell: null,
      mouse: { x: 0, y: 0, active: false }
    };

    function resize() {
      const rect = canvas.getBoundingClientRect();
      state.width = Math.max(1, Math.floor(rect.width));
      state.height = Math.max(1, Math.floor(rect.height));
      state.dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width = Math.floor(state.width * state.dpr);
      canvas.height = Math.floor(state.height * state.dpr);
      ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
    }

    function resolveHoverCell() {
      if (!state.mouse.active) {
        state.hoverCell = null;
        return;
      }

      const cellX = Math.floor((state.mouse.x + state.offsetX) / state.squareSize);
      const cellY = Math.floor((state.mouse.y + state.offsetY) / state.squareSize);
      state.hoverCell = { x: cellX, y: cellY };
    }

    function draw() {
      ctx.clearRect(0, 0, state.width, state.height);
      resolveHoverCell();

      const startX = -state.squareSize - (state.offsetX % state.squareSize);
      const startY = -state.squareSize - (state.offsetY % state.squareSize);
      const cols = Math.ceil(state.width / state.squareSize) + 3;
      const rows = Math.ceil(state.height / state.squareSize) + 3;

      for (let row = 0; row < rows; row += 1) {
        for (let col = 0; col < cols; col += 1) {
          const x = startX + col * state.squareSize;
          const y = startY + row * state.squareSize;
          const logicalX = Math.floor((x + state.offsetX) / state.squareSize);
          const logicalY = Math.floor((y + state.offsetY) / state.squareSize);

          if (
            state.hoverCell &&
            logicalX === state.hoverCell.x &&
            logicalY === state.hoverCell.y
          ) {
            ctx.fillStyle = state.hoverColor;
            ctx.fillRect(x, y, state.squareSize, state.squareSize);
          }

          ctx.strokeStyle = state.borderColor;
          ctx.strokeRect(x, y, state.squareSize, state.squareSize);
        }
      }

      // Keep the background clean: no extra global vignette overlay.
    }

    function frame() {
      if (!state.running) return;

      state.offsetX = (state.offsetX + state.speed) % state.squareSize;
      state.offsetY = (state.offsetY + state.speed * 0.35) % state.squareSize;
      draw();
      state.raf = requestAnimationFrame(frame);
    }

    function onMouseMove(event) {
      const rect = canvas.getBoundingClientRect();
      state.mouse.x = event.clientX - rect.left;
      state.mouse.y = event.clientY - rect.top;
      state.mouse.active = (
        state.mouse.x >= 0 &&
        state.mouse.x <= rect.width &&
        state.mouse.y >= 0 &&
        state.mouse.y <= rect.height
      );
    }

    function onMouseLeave() {
      state.mouse.active = false;
      state.hoverCell = null;
    }

    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', onMouseMove, { passive: true });
    window.addEventListener('mouseleave', onMouseLeave, { passive: true });

    resize();
    draw();

    return {
      setActive(active) {
        if (active === state.running) return;
        state.running = active;

        if (state.running) {
          frame();
        } else if (state.raf) {
          cancelAnimationFrame(state.raf);
          state.raf = 0;
        }
      }
    };
  }

  function ensureSquaresController() {
    if (squaresController) return squaresController;
    const backdrop = ensureBackdrop();
    const canvas = backdrop.querySelector('#rb-dark-squares');
    squaresController = createSquaresController(canvas);
    return squaresController;
  }

  function syncBackdrop(effectiveTheme) {
    const isDark = effectiveTheme === THEME_DARK;
    const darkBackdrop = ensureBackdrop();
    const lightBackdrop = ensureLightBackdrop();
    darkBackdrop.classList.toggle('is-active', isDark);
    lightBackdrop.classList.toggle('is-active', !isDark);

    const controller = ensureSquaresController();
    if (controller) controller.setActive(isDark);
  }

  function applyTheme(theme, persist) {
    const effectiveTheme = getEffectiveTheme(theme);
    root.dataset.userTheme = theme;
    root.dataset.themeEffective = effectiveTheme;

    if (isValidTheme(theme)) {
      root.style.colorScheme = theme;
    } else {
      root.style.removeProperty('color-scheme');
    }

    if (persist) {
      try {
        if (theme === THEME_SYSTEM) {
          localStorage.removeItem(STORAGE_KEY);
        } else {
          localStorage.setItem(STORAGE_KEY, theme);
        }
      } catch (error) {}
    }

    syncThemeColorMeta(effectiveTheme);
    updateMenuButton(effectiveTheme);
    syncBackdrop(effectiveTheme);
  }

  function toggleTheme() {
    const currentTheme = getSavedTheme();
    const currentEffective = getEffectiveTheme(currentTheme);
    const nextTheme = currentEffective === THEME_DARK ? THEME_LIGHT : THEME_DARK;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const apply = () => applyTheme(nextTheme, true);

    if (!prefersReducedMotion && typeof document.startViewTransition === 'function') {
      document.startViewTransition(apply);
      return;
    }

    if (prefersReducedMotion) {
      apply();
      return;
    }

    ensureThemeTransitionLayer();
    root.classList.add('theme-animating');
    root.dataset.themeTarget = nextTheme;

    requestAnimationFrame(() => {
      apply();
      if (themeAnimTimer) {
        clearTimeout(themeAnimTimer);
      }
      themeAnimTimer = window.setTimeout(() => {
        root.classList.remove('theme-animating');
        delete root.dataset.themeTarget;
      }, 460);
    });
  }

  function refresh() {
    bindToggle(ensureMenuToggle());
    applyTheme(getSavedTheme(), false);
  }

  function syncSystemTheme() {
    if (getSavedTheme() === THEME_SYSTEM) {
      applyTheme(THEME_SYSTEM, false);
    }
  }

  if (typeof media.addEventListener === 'function') {
    media.addEventListener('change', syncSystemTheme);
  } else if (typeof media.addListener === 'function') {
    media.addListener(syncSystemTheme);
  }

  window.addEventListener('DOMContentLoaded', refresh);
  document.addEventListener('pjax:success', refresh);

  window.__siteThemeController = { refresh };
  refresh();
})();
</script>
